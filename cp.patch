diff --git a/acting/core/src/ompas/manager/planning/mod.rs b/acting/core/src/ompas/manager/planning/mod.rs
index b9a949e..90cf00e 100644
--- a/acting/core/src/ompas/manager/planning/mod.rs
+++ b/acting/core/src/ompas/manager/planning/mod.rs
@@ -330,7 +330,7 @@ impl PlannerInstance {
                         }
                     }
 
-                    if OMPAS_CHRONICLE_DEBUG.get() >= ChronicleDebug::Full {
+                    if OMPAS_CHRONICLE_DEBUG_ON.get() >= ChronicleDebug::Full {
                         for instance in &problem.chronicles {
                             Printer::print_chronicle(&instance.chronicle, &problem.context.model);
                         }
diff --git a/acting/core/src/planning/planner/encoding/domain.rs b/acting/core/src/planning/planner/encoding/domain.rs
index 29b4b9f..f0164cf 100644
--- a/acting/core/src/planning/planner/encoding/domain.rs
+++ b/acting/core/src/planning/planner/encoding/domain.rs
@@ -11,7 +11,7 @@ use crate::model::sym_domain::cst::Cst;
 use crate::model::sym_domain::Domain::Simple;
 use crate::model::sym_domain::{Domain, TypeId};
 use crate::model::sym_table::r#ref::RefSymTable;
-use crate::model::sym_table::r#trait::GetVariables;
+use crate::model::sym_table::r#trait::{FormatWithSymTable, GetVariables};
 use crate::model::sym_table::VarId;
 use crate::ompas::manager::planning::acting_var_ref_table::ActingVarRefTable;
 use crate::ompas::manager::state::instance::InstanceCollection;
@@ -28,10 +28,11 @@ use aries::model::types::TypeHierarchy;
 use aries::utils::input::Sym;
 use aries_planning::chronicles::constraints::{Constraint as aConstraint, ConstraintType};
 use aries_planning::chronicles::printer::Printer;
+use aries_planning::chronicles::EffectOp::Assign;
 use aries_planning::chronicles::{
     Chronicle as aChronicle, ChronicleKind as aChronicleKind,
-    ChronicleTemplate as aChronicleTemplate, Condition, Container, Ctx, Effect, StateFun, SubTask,
-    VarType, TIME_SCALE,
+    ChronicleTemplate as aChronicleTemplate, Condition, Container, Ctx, Effect, Fluent, StateVar,
+    SubTask, VarType, TIME_SCALE,
 };
 use aries_planning::parsing::pddl::TypedSymbol;
 use function_name::named;
@@ -128,7 +129,10 @@ pub fn encode_ctx(
             args.push(get_type(&lattice, &symbol_table, tpe)?);
         }
         args.push(get_type(&lattice, &symbol_table, &sf.result)?);
-        state_functions.push(StateFun { sym, tpe: args })
+        state_functions.push(Fluent {
+            sym,
+            signature: args,
+        })
     }
 
     Ok(Ctx::new(Arc::new(symbol_table), state_functions))
@@ -175,7 +179,7 @@ fn convert_constraint(
             let b: FAtom = get_atom(&b, ctx).try_into().map_err(|c: ConversionError| {
                 LRuntimeError::new("conversion_error", c.to_string())
             })?;
-            aConstraint::fleq(a, b)
+            aConstraint::leq(a, b)
         }
         Constraint::Eq(a, b) => match (a, b) {
             (Lit::Atom(a), Lit::Atom(b)) => aConstraint::eq(get_atom(a, ctx), get_atom(b, ctx)),
@@ -331,7 +335,7 @@ fn convert_constraint(
                     cst += factor * shift;
                     match var {
                         IVar::ZERO => {}
-                        _ => terms.push(LinearTerm::new(factor, var, false)),
+                        _ => terms.push(LinearTerm::new(factor, var, true.into(), 1)),
                     }
                 }
 
@@ -686,14 +690,26 @@ pub fn read_chronicle(
 
     //print!("init conditions...");
     for c in ch.get_conditions() {
-        let sv =
-            c.sv.iter()
-                .map(|a| {
-                    get_atom(a, ctx)
-                        .try_into()
-                        .unwrap_or_else(|e| panic!("{}", e))
-                })
-                .collect();
+        let fluent = ctx
+            .get_fluent(
+                ctx.model
+                    .get_symbol_table()
+                    .id(&c.sv[0].format(&st, true))
+                    .unwrap(),
+            )
+            .unwrap()
+            .clone();
+
+        let args = c.sv[1..]
+            .iter()
+            .map(|a| {
+                get_atom(a, ctx)
+                    .try_into()
+                    .unwrap_or_else(|e| panic!("{}", e))
+            })
+            .collect();
+        let sv = StateVar { fluent, args };
+
         let value = get_atom(&c.value, ctx);
         let start: FAtom = get_atom(&c.get_start(), ctx).try_into()?;
         let end: FAtom = get_atom(&c.get_end(), ctx).try_into()?;
@@ -709,14 +725,26 @@ pub fn read_chronicle(
 
     //print!("init effects...");
     for e in ch.get_effects() {
-        let sv =
-            e.sv.iter()
-                .map(|a| {
-                    get_atom(a, ctx)
-                        .try_into()
-                        .unwrap_or_else(|e| panic!("{}", e))
-                })
-                .collect();
+        let fluent = ctx
+            .get_fluent(
+                ctx.model
+                    .get_symbol_table()
+                    .id(&e.sv[0].format(&st, true))
+                    .unwrap(),
+            )
+            .unwrap()
+            .clone();
+
+        let args = e.sv[1..]
+            .iter()
+            .map(|a| {
+                get_atom(a, ctx)
+                    .try_into()
+                    .unwrap_or_else(|e| panic!("{}", e))
+            })
+            .collect();
+        let sv = StateVar { fluent, args };
+
         let value = get_atom(&e.value, ctx);
         let start: FAtom = get_atom(&e.get_start(), ctx).try_into()?;
         let end: FAtom = get_atom(&e.get_end(), ctx).try_into()?;
@@ -725,7 +753,7 @@ pub fn read_chronicle(
             persistence_start: end,  // + FAtom::EPSILON,
             min_persistence_end: vec![],
             state_var: sv,
-            value,
+            operation: Assign(value),
         };
         effects.push(effect);
     }
diff --git a/acting/core/src/planning/planner/encoding/mod.rs b/acting/core/src/planning/planner/encoding/mod.rs
index 0c50d54..26afc57 100644
--- a/acting/core/src/planning/planner/encoding/mod.rs
+++ b/acting/core/src/planning/planner/encoding/mod.rs
@@ -12,7 +12,7 @@ use crate::planning::planner::encoding::domain::encode_ctx;
 use crate::planning::planner::encoding::instance::generate_instances;
 use crate::planning::planner::problem::ChronicleInstance;
 use anyhow::Result;
-use aries::core::Lit as aLit;
+use aries::core::{Lit as aLit, INT_CST_MAX, INT_CST_MIN};
 use aries::model::extensions::Shaped;
 use aries::model::lang::{
     Atom as aAtom, ConversionError, FAtom, FVar, IAtom, IVar, SAtom, Type as aType, Variable,
@@ -107,7 +107,10 @@ pub fn get_type(
     match t {
         Domain::Simple(t) => match *t {
             TYPE_ID_BOOLEAN => Ok(aType::Bool),
-            TYPE_ID_INT => Ok(aType::Int),
+            TYPE_ID_INT => Ok(aType::Int {
+                lb: INT_CST_MIN,
+                ub: INT_CST_MAX,
+            }),
             TYPE_ID_FLOAT => Ok(aType::Fixed(TIME_SCALE.get())),
             t => {
                 let other: String = lattice.format_type(&t);
@@ -120,6 +123,10 @@ pub fn get_type(
                 }
             }
         },
+        Domain::IntRange(lb, ub) => Ok(aType::Int {
+            lb: *lb as i32,
+            ub: *ub as i32,
+        }),
         t => Err(LRuntimeError::new(
             function_name!(),
             format!("{} not supported yet in aries encoding", t.format(lattice)),
diff --git a/aries b/aries
index efe8866..ac57006 160000
--- a/aries
+++ b/aries
@@ -1 +1 @@
-Subproject commit efe8866887509fa7db385bc01fce8fad140d88b6
+Subproject commit ac5700697ff4b78722635896571c476f59890da9
diff --git a/ompas-gobot-sim/planning_domain/domain_plan.lisp b/ompas-gobot-sim/planning_domain/domain_plan.lisp
index 588d3c2..a860b70 100644
--- a/ompas-gobot-sim/planning_domain/domain_plan.lisp
+++ b/ompas-gobot-sim/planning_domain/domain_plan.lisp
@@ -6,11 +6,12 @@
     ;(read planning_domain/problems/j06.lisp)
     (read planning_domain/problems/j01.lisp)
 
-    (start-with-planner false)
+    ;(start-with-planner false)
     ;(start)
     ;(activate_log log-ompas)
-    (wait-task (trigger-task t_jobshop))
+    ;(wait-task (trigger-task t_jobshop))
+    ;(wait-task (trigger-task t_carry_to_machine robot0 package0 machine0))
     ;(wait-task (trigger-task t_process_on_machine package0 machine0 3))
-    (stop)
+    ;(stop)
     (exit 0)
 )
